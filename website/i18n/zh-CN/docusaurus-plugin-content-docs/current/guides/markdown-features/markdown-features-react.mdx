---
id: react
description: 得益于 MDX，你可以在 Docusaurus Markdown 文档中使用 React
slug: /markdown-features/react
---

# MDX 和 React

```mdx-code-block
import BrowserWindow from '@site/src/components/BrowserWindow';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import styles from './markdown-features-react.module.css';
```

Docusaurus 原生支持 [MDX v2](https://mdxjs.com/)，可以直接在 Markdown 文档中编写 JSX，并把渲染为 React 组件。

请查看[MDX文档](https://mdxjs.com/)，了解您可以使用MDX做些什么有趣的事情。

:::提示 调试MDX

MDX格式是相当严格的，您可能会遇到编译错误。

使用**[MDX playground](https://mdxjs.com/playground/)**来调试并确保您的语法是有效的。

:::

:::info

Prettier, 最受欢迎的格式, [仅支持遗留的 MDX v1](https://github.com/prettier/prettier/issues/12209) 如果您遇到意外的格式化结果，您可能需要在问题区域前添加` {/* prettier-ignore */} `，或者将` *.mdx `添加到您的 `.prettierignore `中，直到 Prettier 对 MDX v3 有适当的支持。 [ MDX的一位主要作者推荐使用带有`remark-mdx`的`remark-cli`](https://github.com/orgs/mdx-js/discussions/2067)。

:::

### 导出组件 {#exporting-components}

要在MDX文件中定义任何自定义组件，您必须将其导出：只有以`export`开头的段落才会被解析为组件，而非普通文本。

```jsx
export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

<Highlight color="#25c2a0">Docusaurus 绿</Highlight> 和 <Highlight color="#1877F2">Facebook 蓝</Highlight> 是我最喜欢的颜色。

我可以把我的 _JSX_ 和 **Markdown** 写在一起！
```

注意它是怎么同时渲染 React 组件和 Markdown 语法的：

```mdx-code-block
export const Highlight = ({children, color}) => (
  <span
    style={{
      backgroundColor: color,
      borderRadius: '2px',
      color: '#fff',
      padding: '0.2rem',
    }}>
    {children}
  </span>
);

<BrowserWindow minHeight={240}>

<><Highlight color="#25c2a0">Docusaurus green</Highlight>
{` `}and <Highlight color="#1877F2">Facebook blue</Highlight> are my favorite colors.</>

I can write **Markdown** alongside my _JSX_!

</BrowserWindow>
```

:::warning MDX 是 JSX

由于所有文档文件都是使用MDX解析的，任何看起来像HTML的内容实际上是JSX语法。 因此，如果您需要对组件进行内联样式处理，请遵循JSX风格，并提供样式对象。

{/* prettier-ignore */}
```jsx
/* 不要这么写： */
<span style="background-color: red">Foo</span>
/* 要这么写： */
<span style={{backgroundColor: 'red'}}>Foo</span>
```

:::

### 导入组件 {#importing-components}

您还可以导入其他文件中定义的自己的组件或通过npm安装的第三方组件。

{/* prettier-ignore */}
```md
<!-- Docusaurus 主题组件 -->
import TOCInline from '@theme/TOCInline';
<!-- 外部组件 -->
import Button from '@mui/material/Button';
<!-- 自定义组件 -->
import BrowserWindow from '@site/src/components/BrowserWindow';
```

:::tip

`@site` 别名指向您的网站目录，通常是 `docusaurus.config.js` 文件。 如果用别名导入而不是相对路径 (`'../src/components/BrowserWindow'`)导入，你就不需要在移动文件、[划分文档版本](../docs/versioning.mdx)，和[国际化翻译](../../i18n/i18n-tutorial.mdx)文档时，更新所有的导入路径。

:::

对于简单的情况，在 Markdown 中直接声明组件非常方便，但由于编辑器的支持有限，有解析错误的风险，以及可复用性低，这种做法长期来看很难维护。 当您的组件包含了复杂的 JS 逻辑时，最好使用单独的 `.js` 文件：

```jsx title="src/components/Highlight.js"
import React from 'react';

export default function Highlight({children, color}) {
  return (
    <span
      style={{
        backgroundColor: color,
        borderRadius: '2px',
        color: '#fff',
        padding: '0.2rem',
      }}>
      {children}
    </span>
  );
}
```

```md title="markdown-file.mdx"
import Highlight from '@site/src/components/Highlight';

<Highlight color="#25c2a0">Docusaurus 绿</Highlight>
```

:::tip

如果你在许多文件中都用到了同一个组件，你不需要每一次都导入它——你可以考虑把它添加到全局范围导入。 [参见下文](#mdx-component-scope)

:::

### MDX 组件作用域 {#mdx-component-scope}

Apart from [importing a component](#importing-components) and [exporting a component](#exporting-components), a third way to use a component in MDX is to **register it to the global scope**, which will make it automatically available in every MDX file, without any import statements.

例如，在下面给定的 MDX 文件中：

```md
- 一个
- 列表！

和一些 <Highlight>自定义标记</Highlight>……
```

它会被编译成一个包含 `ul`、`li`、`p`、`highlight` 标签的 React 组件。 ` Highlight ` 不是原生的 html 元素：你需要为它提供你自己的 React 组件的实现。

在 Docusaurus 中，MDX 组件作用域是由 `@theme/MDXComponents` 组件提供的。 It's not a React component, _per se_, unlike most other exports under the `@theme/` alias: it is a record from tag names like `Highlight` to their React component implementations.

If you [swizzle](../../swizzling.mdx) this component, you will find all tags that have been implemented, and you can further customize our implementation by swizzling the respective sub-component, like `@theme/MDXComponents/Code` (which is used to render [Markdown code blocks](./markdown-features-code-blocks.mdx)).

If you want to register extra tag names (like the `<Highlight>` tag above), you should consider [wrapping `@theme/MDXComponents`](../../swizzling.mdx#wrapping), so you don't have to maintain all the existing mappings. Since the swizzle CLI doesn't allow wrapping non-component files yet, you should manually create the wrapper:

```js title="src/theme/MDXComponents.js"
import React from 'react';
// Import the original mapper
import MDXComponents from '@theme-original/MDXComponents';
// highlight-next-line
import Highlight from '@site/src/components/Highlight';

export default {
  // Re-use the default mapping
  ...MDXComponents,
  // Map the "<Highlight>" tag to our Highlight component
  // `Highlight` will receive all props that were passed to `<Highlight>` in MDX
  // highlight-next-line
  Highlight,
};
```

现在，您可以在每个页面随意使用 `<Highlight>` 而不需要导入它：

```md
I can conveniently use <Highlight color="#25c2a0">Docusaurus green</Highlight> everywhere!
```

```mdx-code-block
<BrowserWindow>

I can conveniently use <Highlight color="#25c2a0">Docusaurus green</Highlight> everywhere!

</BrowserWindow>
```

:::warning

We use **upper-case** tag names like `Highlight` on purpose.

From MDX v3+ onward (Docusaurus v3+), lower-case tag names are always rendered as native html elements, and will not use any component mapping you provide.

:::

:::warning

这个功能由[一个`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider)提供支持。 If you are importing Markdown in a React page, you have to supply this provider yourself through the `MDXContent` theme component.

```jsx title="src/pages/index.js"
import React from 'react';
import FeatureDisplay from './_featureDisplay.mdx';
// highlight-next-line
import MDXContent from '@theme/MDXContent';

export default function LandingPage() {
  return (
    <div>
      {/* highlight-start */}
      <MDXContent>
        <FeatureDisplay />
      </MDXContent>
      {/* highlight-end */}
    </div>
  );
}
```

如果您不使用 `MDXContent`包装您导入的 MDX ，全局范围将不可用。

:::

### Markdown 和 JSX 的交互 {#markdown-and-jsx-interoperability}

Docusaurus v3 正在使用 [MDX v3](https://mdxjs.com/blog/v3/)

The [MDX syntax](https://mdxjs.com/docs/what-is-mdx/#mdx-syntax) is mostly compatible with [CommonMark](https://commonmark.org/), but is much stricter because your `.mdx` files can use JSX and are compiled into real React components (check the [playground](https://mdxjs.com/playground/)).

Some valid CommonMark features won't work with MDX ([more info](https://mdxjs.com/docs/what-is-mdx/#markdown)), notably:

- Indented code blocks: use triple backticks instead
- Autolinks (`<http://localhost:3000>`): use regular link syntax instead (`[http://localhost:3000](http://localhost:3000)`)
- HTML syntax (`<p style="color: red;">`): use JSX instead (`<p style={{color: 'red'}}>`)
- Unescaped `{` and `<`: escape them with `\` instead (`\{` and `\<`)

:::danger 实验性的 CommonMark 支持

Docusaurus v3 可以通过以下选项为  [CommonMark](https://commonmark.org/)  实现不太严格、不太标准的支持：

- The `mdx.format: md` 前言
- The `.md` file extension combined with the `siteConfig.markdown.format: "detect"` configuration

此功能是**实验性**的 ，目前有几个[限制](https://github.com/facebook/docusaurus/issues/9092)。

:::

## 导入代码片段 {#importing-code-snippets}

You can not only import a file containing a component definition, but also import any code file as raw text, and then insert it in a code block, thanks to [Webpack raw-loader](https://webpack.js.org/loaders/raw-loader/). In order to use `raw-loader`, you first need to install it in your project:

```bash npm2yarn
npm install --save raw-loader
```

现在您可以从另一个文件导入代码片段：

{/* prettier-ignore */}
```jsx title="myMarkdownFile.mdx"
import CodeBlock from '@theme/CodeBlock';
import MyComponentSource from '!!raw-loader!./myComponent';

<CodeBlock language="jsx">{MyComponentSource}</CodeBlock>
```

```mdx-code-block
import CodeBlock from '@theme/CodeBlock';
import MyComponentSource from '!!raw-loader!@site/src/pages/examples/_myComponent';

<BrowserWindow>

<CodeBlock language="jsx">{MyComponentSource}</CodeBlock>

</BrowserWindow>
```

请参阅 [在 JSX 中使用代码块](./markdown-features-code-blocks.mdx#usage-in-jsx) 来了解 `<CodeBlock>` 组件的详细信息。

:::note

You have to use `<CodeBlock>` rather than the Markdown triple-backtick ` ``` `, because the latter will ship out any of its content as-is, but you want to interpolate the imported text here.

:::

:::warning

这个功能是试验性的，未来 API 可能会有破坏性变更。

:::

## 导入 Markdown {#importing-markdown}

You can use Markdown files as components and import them elsewhere, either in Markdown files or in React pages. Each MDX file default-exports its page content as a React component. In the `import` statement, you can default-import this component with any name, but it must be capitalized following React's naming rules.

By convention, using the **`_` filename prefix** will not create any doc page and means the Markdown file is a **"partial"**, to be imported by other files.

```md title="_markdown-partial-example.mdx"
<span>Hello {props.name}</span>

This is text some content from `_markdown-partial-example.mdx`.
```

{/* prettier-ignore */}
```jsx title="someOtherDoc.mdx"
import PartialExample from './_markdown-partial-example.mdx';

<PartialExample name="Sebastien" />
```

```mdx-code-block
import PartialExample from './_markdown-partial-example.mdx';

<BrowserWindow>
  <PartialExample name="Sebastien" />
</BrowserWindow>
```

这样，你可以在多个文档中复用内容，避免重复编写。

## 可用导出 {#available-exports}

在 MDX 页面内，以下变量可作为全局变量：

- `frontMatter`：Markdown 文档的前言，包含字符串键和对应的值；
- `toc`：目录，作为一个标题列表。 参考[ 行内目录 ](./markdown-features-toc.mdx#inline-table-of-contents) 查看更实际的用法。
- `contentTitle` ：Markdown 的标题，是 Markdown 正文中的第一个 `h1` 。 如果没有则是 `undefined`（例如把标题定义在了文档的前言中）。

```jsx
import TOCInline from '@theme/TOCInline';
import CodeBlock from '@theme/CodeBlock';

The table of contents for this page, serialized:

<CodeBlock className="language-json">{JSON.stringify(toc, null, 2)}</CodeBlock>

The front matter of this page:

<ul>
  {Object.entries(frontMatter).map(([key, value]) => <li key={key}><b>{key}</b>: {value}</li>)}
</ul>

<p>The title of this page is: <b>{contentTitle}</b></p>
```

```mdx-code-block
import TOCInline from '@theme/TOCInline';

<BrowserWindow>

The table of contents for this page, serialized:

<CodeBlock className="language-json">{JSON.stringify(toc, null, 2)}</CodeBlock>

The front matter of this page:

<ul>
  {Object.entries(frontMatter).map(([key, value]) => <li key={key}><b>{key}</b>: {value}</li>)}
</ul>

<p>The title of this page is: <b>{contentTitle}</b></p>

</BrowserWindow>
```
