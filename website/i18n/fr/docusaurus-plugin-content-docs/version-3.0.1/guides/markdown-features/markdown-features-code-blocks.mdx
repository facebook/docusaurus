---
id: code-blocks
description: Manipulation des blocs de code dans le Markdown de Docusaurus
slug: /markdown-features/code-blocks
---

# Blocs de code

import BrowserWindow from '@site/src/components/BrowserWindow';
import CodeBlock from '@theme/CodeBlock';

Les blocs de code dans la documentation sont super-puissants üí™.

## Titre du code {#code-title}

Vous pouvez ajouter un titre au bloc de code en ajoutant une cl√© `title` apr√®s le language (laisser un espace entre les deux).

````md
```jsx title="/src/components/HelloCodeTitle.js"
function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
````

```mdx-code-block
<BrowserWindow>
```

```jsx title="/src/components/HelloCodeTitle.js"
function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

```mdx-code-block
</BrowserWindow>
```

## Coloration syntaxique {#syntax-highlighting}

Les blocs de code sont des blocs de texte envelopp√©s par des cha√Ænes de 3 backticks. Vous pouvez consulter [cette r√©f√©rence](https://github.com/mdx-js/specification) pour les sp√©cifications du MDX.

````md
```js
console.log('Chaque d√©p√¥t doit √™tre accompagn√© d\'une mascotte.');
```
````

Utilisez la m√©ta-cha√Æne du langage correspondant pour votre bloc de code et Docusaurus r√©cup√©rera automatiquement la coloration syntaxique, aliment√©e par [Prism React Renderer](https://github.com/FormidableLabs/prism-react-renderer).

<BrowserWindow>

```js
console.log('Chaque d√©p√¥t doit √™tre accompagn√© d'une mascotte.');
```

</BrowserWindow>

### Th√®me {#theming}

Par d√©faut, le [th√®me de coloration syntaxique](https://github.com/FormidableLabs/prism-react-renderer#theming) de Prism que nous utilisons est [Palenight](https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/prism-react-renderer/src/themes/palenight.ts). Vous pouvez changer cela pour un autre th√®me en passant le champ `theme` dans `prism` en tant que `themeConfig` dans votre docusaurus.config.js.

Par exemple, si vous pr√©f√©rez utiliser le th√®me de coloration `dracula`¬†:

```js title="docusaurus.config.js"
import {themes as prismThemes} from 'prism-react-renderer';

export default {
  themeConfig: {
    prism: {
      // highlight-next-line
      theme: prismThemes.dracula,
    },
  },
};
```

Comme un th√®me Prism n'est qu'un objet JS, vous pouvez √©galement √©crire votre propre th√®me si vous n'√™tes pas satisfait du th√®me par d√©faut. Docusaurus am√©liore les th√®mes `github` et `vsDark` pour fournir une mise en √©vidence plus riche, et vous pouvez v√©rifier nos impl√©mentations pour les th√®mes de blocs de code [clair](https://github.com/facebook/docusaurus/blob/main/website/src/utils/prismLight.ts) et [sombre](https://github.com/facebook/docusaurus/blob/main/website/src/utils/prismDark.ts).

### Langages pris en charge {#supported-languages}

Par d√©faut, Docusaurus est fourni avec un sous-ensemble de [langages couramment utilis√©s](https://github.com/FormidableLabs/prism-react-renderer/blob/master/packages/generate-prism-languages/index.ts#L9-L23).

:::warning

Certains langages populaires comme Java, C# ou PHP ne sont pas activ√©s par d√©faut.

:::

Pour ajouter la coloration syntaxique pour n'importe lequel des autres [langages pris en charge par Prism](https://prismjs.com/#supported-languages), d√©finissez-la dans un tableau de langages suppl√©mentaires.

:::note

Chaque langage suppl√©mentaire doit √™tre un nom de composant Prism valide. Par exemple, Prism mettrait en correspondance le _langage_ `cs` avec `csharp`, mais seul `prism-csharp.js` existe en tant que _composant_, vous devez donc utiliser `additionalLanguages: ['csharp']`. Vous pouvez consulter `node_modules/prismjs/components` pour trouver tous les composants (langages) disponibles.

:::

Par exemple, si vous voulez ajouter une coloration pour le langage PowerShell¬†:

```js title="docusaurus.config.js"
export default {
  // ...
  themeConfig: {
    prism: {
      // highlight-next-line
      additionalLanguages: ['powershell'],
    },
    // ...
  },
};
```

Apr√®s avoir ajout√© `additionalLanguages`, red√©marrez Docusaurus.

Si vous souhaitez ajouter la coloration pour des langages qui ne sont pas encore pris en charge par Prism, vous pouvez ¬´¬†swizzler¬†¬ª le `prism-include-languages`¬†:

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic prism-include-languages
```

Il g√©n√®rera `prism-include-languages.js` dans votre dossier `src/theme`. Vous pouvez ajouter le support de mise en √©vidence pour les langages personnalis√©s en √©ditant `prism-include-languages.js`¬†:

```js title="src/theme/prism-include-languages.js"
const prismIncludeLanguages = (Prism) => {
  // ...

  additionalLanguages.forEach((lang) => {
    require(`prismjs/components/prism-${lang}`);
  });

  // highlight-next-line
  require('/path/to/your/prism-language-definition');

  // ...
};
```

Vous pouvez vous r√©f√©rer aux [d√©finitions des langages officiels de Prism] (https://github.com/PrismJS/prism/tree/master/components) lorsque vous r√©digez vos propres d√©finitions de langages.

Lors de l'ajout d'une d√©finition de langage personnalis√©, vous n'avez pas besoin d'ajouter le langage au tableau de configuration `additionalLanguages`, puisque Docusaurus ne regarde que les cha√Ænes `additionalLanguages` dans les langages que le Prism fournit. Ajouter l'importation de langage dans `prism-include-languages.js` est suffisant.

## Surlignage de la ligne {#line-highlighting}

### Surlignage avec les commentaires {#highlighting-with-comments}

Vous pouvez utiliser des commentaires avec `highlight-next-line`, `highlight-start`, et `highlight-end` pour s√©lectionner les lignes en surbrillance.

````md
```js
function HighlightSomeText(highlight) {
  if (highlight) {
    // highlight-next-line
    return 'Ce texte est surlign√©¬†!';
  }

  return 'Rien de surlign√©';
}

function HighlightMoreText(highlight) {
  // highlight-start
  if (highlight) {
    return 'Cette plage est surlign√©e¬†!';
  }
  // highlight-end

  return 'Rien de surlign√©';
}
```
````

```mdx-code-block
<BrowserWindow>
```

```js
function HighlightSomeText(highlight) {
  if (highlight) {
    // highlight-next-line
    return 'Ce texte est surlign√©¬†!';
  }

  return 'Rien de surlign√©';
}

function HighlightMoreText(highlight) {
  // highlight-start
  if (highlight) {
    return 'Cette plage est surlign√©e¬†!';
  }
  // highlight-end

  return 'Rien de surlign√©';
}
```

```mdx-code-block
</BrowserWindow>
```

Syntaxe de commentaire support√©e :

| Style      | Syntaxe                   |
| ---------- | ------------------------- |
| Style C    | `/* ... */` et `// ...`   |
| Style JSX  | `{/* ... */}`             |
| Style Bash | `# ...`                   |
| Style HTML | `<!-- ... -->`            |

Nous ferons de notre mieux pour d√©duire quel ensemble de styles de commentaires utiliser en fonction du langage, et autoriser par d√©faut _tous_ les styles de commentaires. S'il y a une style de commentaire qui n'est pas actuellement support√©e, nous sommes ouverts √† les ajouter ! Les pull requests sont les bienvenues. Notez que les diff√©rents styles de commentaires ne pr√©sentent aucune diff√©rence s√©mantique, seul leur contenu en pr√©sente une.

Vous pouvez d√©finir votre propre couleur d'arri√®re-plan pour la ligne du code surlign√©e dans votre `src/css/custom.css` qui s'adaptera mieux au th√®me de coloration syntaxique que vous avez choisi. La couleur indiqu√©e ci-dessous fonctionne pour le th√®me de surbrillance par d√©faut (Palenight), donc si vous utilisez un autre th√®me, vous devrez modifier la couleur en cons√©quence.

```css title="/src/css/custom.css"
:root {
  --docusaurus-highlighted-code-line-bg: rgb(72, 77, 91);
}

/* Si vous avez un th√®me de coloration syntaxique diff√©rent pour le mode sombre. */
[data-theme='dark'] {
  /* Couleur qui fonctionne avec le th√®me de la coloration syntaxique du mode sombre */
  --docusaurus-highlighted-code-line-bg: rgb(100, 100, 100);
}
```

Si vous avez √©galement besoin de styliser la ligne de code surlign√©e d'une autre mani√®re, vous pouvez vous appuyer sur la classe CSS `theme-code-block-highlighted-line`.

### Surlignage avec une cha√Æne de m√©tadonn√©es {#highlighting-with-metadata-string}

Vous pouvez √©galement sp√©cifier des plages de lignes en surbrillance dans la m√©ta-cha√Æne du langage (laisser un espace apr√®s le langage). Pour surligner plusieurs lignes, s√©parez les num√©ros de lignes par des virgules ou utilisez la syntaxe de l'intervalle pour s√©lectionner un morceau de lignes. Cette fonctionnalit√© utilise la biblioth√®que `parse-number-range` et vous pouvez trouver [plus de syntaxe](https://www.npmjs.com/package/parse-numeric-range) dans les d√©tails de leur projet.

````md
```jsx {1,4-6,11}
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```
````

```mdx-code-block
<BrowserWindow>
```

```jsx {1,4-6,11}
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```

```mdx-code-block
</BrowserWindow>
```

:::tip pr√©f√®rez les commentaires

Pr√©f√©rez la mise en surbrillance avec des commentaires lorsque vous le pouvez. En mettant en surbrillance le code, vous ne devez pas compter manuellement les lignes si votre bloc de code devient long. Si vous ajoutez/supprimez des lignes, vous n'avez pas non plus √† d√©caler vos plages de lignes.

````diff
- ```jsx {3}
+ ```jsx {4}
  function HighlightSomeText(highlight) {
    if (highlight) {
+     console.log('Texte surlign√© trouv√©');
      return 'Ce texte est surlign√©¬†!';
    }

    return 'Rien de surlign√©';
  }
  ```
````

Ci-dessous, nous allons pr√©senter comment le syst√®me de commentaire magique peut √™tre √©tendu pour d√©finir des directives personnalis√©es et leurs fonctionnalit√©s. Les commentaires magiques ne seront analys√©s que si une mise en surbrillance n'est pas pr√©sente.

:::

### Commentaires magiques personnalis√©s {#custom-magic-comments}

`// highlight-next-line`, `// highlight-start`, etc ..., sont appel√©s ¬´¬†commentaires magiques¬†¬ª, parce qu'ils seront analys√©s et supprim√©s, et leur but est d'ajouter des m√©tadonn√©es √† la ligne suivante, ou √† la section que la paire de commentaires de d√©but et de fin enveloppe.

Vous pouvez d√©clarer des commentaires magiques personnalis√©s √† travers la configuration du th√®me. Par exemple, vous pouvez enregistrer un autre commentaire magique qui ajoute une classe `code-block-error-line`¬†:

```mdx-code-block
<Tabs>
<TabItem value="docusaurus.config.js">
```

```js
export default {
  themeConfig: {
    prism: {
      magicComments: [
        // N'oubliez pas d'√©tendre le nom de la classe de mise en √©vidence par d√©faut !
        {
          className: 'theme-code-block-highlighted-line',
          line: 'highlight-next-line',
          block: {start: 'highlight-start', end: 'highlight-end'},
        },
        // highlight-start
        {
          className: 'code-block-error-line',
          line: 'This will error',
        },
        // highlight-end
      ],
    },
  },
};
```

```mdx-code-block
</TabItem>
<TabItem value="src/css/custom.css">
```

```css
.code-block-error-line {
  background-color: #ff000020;
  display: block;
  margin: 0 calc(-1 * var(--ifm-pre-padding));
  padding: 0 var(--ifm-pre-padding);
  border-left: 3px solid #ff000080;
}
```

```mdx-code-block
</TabItem>
<TabItem value="myDoc.md">
```

````md
En JavaScript, la tentative d'acc√®s aux propri√©t√©s de `null` entra√Æne une erreur.

```js
const name = null;
// Cela provoquera une erreur
console.log(name.toUpperCase());
// Uncaught TypeError: Cannot read properties of null (reading 'toUpperCase')
```
````

```mdx-code-block
</TabItem>
</Tabs>
```

```mdx-code-block
<BrowserWindow>
```

En JavaScript, toute tentative d'acc√®s aux propri√©t√©s de `null` entra√Ænera une erreur.

```js
const name = null;
// This will error
console.log(name.toUpperCase());
// Uncaught TypeError: Cannot read properties of null (reading 'toUpperCase')
```

```mdx-code-block
</BrowserWindow>
```

Si vous utilisez des plages de nombres dans la m√©tastring (la syntaxe `{1,3-4}`), Docusaurus appliquera le nom de classe de la **premi√®re entr√©e `magicComments`**. Par d√©faut, il s'agit de `theme-code-block-highlighted-line`, mais si vous modifiez la configuration de `magicComments` et que vous utilisez une autre entr√©e en premier, la signification de la plage de m√©tastring changera √©galement.

Vous pouvez d√©sactiver la ligne par d√©faut en surlignant les commentaires avec `magicComments: []`. S'il n'y a pas de configuration de commentaire magique, mais que Docusaurus rencontre un bloc de code contenant une plage de m√©tastring, il commettra une erreur parce qu'il n'y aura pas de nom de classe √† appliquer - le nom de classe de m√©tastring, finalement, n'est qu'une entr√©e de commentaire magique.

Chaque entr√©e de commentaire magique contiendra trois cl√©s¬†: `className` (obligatoire), `line`, qui s'applique √† la ligne suivante, ou `block` (contenant `start` et `end`), qui s'applique √† tout le bloc entour√© par les deux commentaires.

L'utilisation de CSS pour cibler la classe peut d√©j√† faire beaucoup, mais vous pouvez d√©bloquer tout le potentiel de cette fonctionnalit√© via le [swizzling](../../swizzling.mdx).

```bash npm2yarn
npm run swizzle @docusaurus/theme-classic CodeBlock/Line
```

Le composant `Line` recevra la liste des noms de classe, √† partir de laquelle vous pouvez rendre conditionnellement diff√©rentes balises.

## Num√©rotation des lignes {#line-numbering}

Vous pouvez activer la num√©rotation de ligne pour votre bloc de code en utilisant la cl√© `showLineNumbers` dans la m√©ta cha√Æne du langage (n'oubliez pas d'ajouter un espace juste avant la cl√©).

````md
```jsx {1,4-6,11} showLineNumbers
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```
````

```mdx-code-block
<BrowserWindow>
```

```jsx {1,4-6,11} showLineNumbers
import React from 'react';

function MyComponent(props) {
  if (props.isBar) {
    return <div>Bar</div>;
  }

  return <div>Foo</div>;
}

export default MyComponent;
```

```mdx-code-block
</BrowserWindow>
```

## √âditeur de code interactif {#interactive-code-editor}

(Propuls√© par [React Live](https://github.com/FormidableLabs/react-live))

Vous pouvez cr√©er un √©diteur de code interactif avec le plugin `@docusaurus/theme-live-codeblock`. Tout d'abord, ajoutez le plugin √† votre package.

```bash npm2yarn
npm install --save @docusaurus/theme-live-codeblock
```

Vous devez √©galement ajouter le plugin √† votre `docusaurus.config.js`.

```js {3}
export default {
  // ...
  themes: ['@docusaurus/theme-live-codeblock'],
  // ...
};
```

Pour utiliser le plugin, cr√©ez un bloc de code avec `live` attach√© √† la m√©ta cha√Æne de langage.

````md
```jsx live
function Clock(props) {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerID = setInterval(() => tick(), 1000);

    return function cleanup() {
      clearInterval(timerID);
    };
  });

  function tick() {
    setDate(new Date());
  }

  return (
    <div>
      <h2>Il est {date.toLocaleTimeString()}.</h2>
    </div>
  );
}
```
````

Le bloc de code sera rendu en tant qu'√©diteur interactif. Les modifications apport√©es au code se r√©percuteront en temps r√©el sur le panneau des r√©sultats.

```mdx-code-block
<BrowserWindow>
```

```jsx live
function Clock(props) {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    const timerID = setInterval(() => tick(), 1000);

    return function cleanup() {
      clearInterval(timerID);
    };
  });

  function tick() {
    setDate(new Date());
  }

  return (
    <div>
      <h2>Il est {date.toLocaleTimeString()}.</h2>
    </div>
  );
}
```

```mdx-code-block
</BrowserWindow>
```

### Imports {#imports}

:::warning react-live et imports

Il n'est pas possible d'importer des composants directement depuis l'√©diteur de code de react-live, vous devez d√©finir les importations n√©cessaires au pr√©alable.

:::

Par d√©faut, toutes les importations de React sont disponibles. Si vous avez besoin d'un plus grand nombre d'importations √† disposition, swizzlez la port√©e de react-live :

```bash npm2yarn
npm run swizzle @docusaurus/theme-live-codeblock ReactLiveScope -- --eject
```

```jsx title="src/theme/ReactLiveScope/index.js"
import React from 'react';

// highlight-start
const ButtonExample = (props) => (
  <button
    {...props}
    style={{
      backgroundColor: 'white',
      color: 'black',
      border: 'solid red',
      borderRadius: 20,
      padding: 10,
      cursor: 'pointer',
      ...props.style,
    }}
  />
);
// highlight-end

// Ajoutez les importations react-live dont vous avez besoin ici
const ReactLiveScope = {
  React,
  ...React,
  // highlight-next-line
  ButtonExample,
};

export default ReactLiveScope;
```

Le composant `ButtonExample` est maintenant disponible pour √™tre utilis√© :

```mdx-code-block
<BrowserWindow>
```

```jsx live
function MyPlayground(props) {
  return (
    <div>
      <ButtonExample onClick={() => alert('hey!')}>Cliquez moi</ButtonExample>
    </div>
  );
}
```

```mdx-code-block
</BrowserWindow>
```

### Rendu imp√©ratif (noInline)

L'option `noInline` doit √™tre utilis√©e pour √©viter les erreurs lorsque votre code s'√©tend sur plusieurs composants ou variables.

````md
```jsx live noInline
const project = 'Docusaurus';

const Greeting = () => <p>Hello {project}!</p>;

render(<Greeting />);
```
````

Contrairement √† un bloc de code interactif ordinaire, lors de l'utilisation de `noInline`, React Live n'enveloppera pas votre code dans une fonction en ligne pour le rendre.

Vous devrez explicitement appeler `render()` √† la fin de votre code pour afficher la sortie.

````mdx-code-block
<BrowserWindow>

```jsx live noInline
const project = "Docusaurus";

const Greeting = () => (
  <p>Hello {project}!</p>
);

render(
  <Greeting />
);
```

</BrowserWindow>
````

## Utiliser le balisage JSX dans les blocs de code {#using-jsx-markup}

Le bloc de code dans Markdown conserve toujours son contenu en texte brut, ce qui signifie que vous ne pouvez pas faire quelque chose comme¬†:

```ts
type EditUrlFunction = (params: {
  // Ceci ne se transforme pas en lien (pour une bonne raison !)
  version: <a href="/docs/versioning">Version</a>;
  versionDocsDirPath: string;
  docPath: string;
  permalink: string;
  locale: string;
}) => string | undefined;
```

Si vous voulez int√©grer le balisage HTML comme les liens d'ancrage ou le type gras, vous pouvez utiliser la balise `<pre>`, `<code>`, ou le composant `<CodeBlock>`.

```jsx
<pre>
  <b>Entr√©e: </b>1 2 3 4{'\n'}
  <b>Sortie: </b>"366300745"{'\n'}
</pre>
```

<BrowserWindow>
  <pre>
    <b>{'Entr√©e: '}</b>
    {'1 2 3 4\n'}
    <b>{'Sortie: '}</b>
    {'"366300745"\n'}
  </pre>
</BrowserWindow>

:::warning MDX est insensible aux espaces

MDX est conforme au comportement JSX : les caract√®res de saut de ligne, m√™me √† l'int√©rieur de `<pre>`, sont transform√©s en espaces. Vous devez √©crire explicitement le caract√®re saut de ligne pour qu'il soit imprim√©.

:::

:::warning

La coloration syntaxique ne fonctionne que sur des cha√Ænes de caract√®res simples. Docusaurus ne tentera pas d'analyser le contenu du bloc de code contenant des fils JSX.

:::

## Blocs de code multi-langages {#multi-language-support-code-blocks}

Avec MDX, vous pouvez facilement cr√©er des composants interactifs dans votre documentation, par exemple, pour afficher du code dans plusieurs langages de programmation et basculer entre eux en utilisant un composant d'onglets.

Au lieu de mettre en place un composant d√©di√© aux blocs de code pour la prise en charge de multi-langage, nous avons impl√©ment√© un composant [`<Tabs>`](./markdown-features-tabs.mdx) pour un usage g√©n√©ral dans le th√®me classic afin que vous puissiez l'utiliser √©galement pour d'autres sc√©narios sans code.

L'exemple suivant montre comment vous pouvez avoir des onglets de code multi-language dans vos documents. Notez que les lignes vides au-dessus et au-dessous de chaque bloc de langage sont **intentionnelles**. Ceci est une [limitation actuelle de MDX](./markdown-features-react.mdx#markdown-and-jsx-interoperability)¬†: vous devez laisser des lignes vides autour de la syntaxe Markdown pour que l'analyseur MDX sache que c'est la syntaxe Markdown et non le JSX.

````jsx
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="js" label="JavaScript">

```js
function helloWorld() {
  console.log('Hello, world!');
}
```

</TabItem>
<TabItem value="py" label="Python">

```py
def hello_world():
  print("Hello, world!")
```

</TabItem>
<TabItem value="java" label="Java">

```java
class HelloWorld {
  public static void main(String args[]) {
    System.out.println("Hello, World");
  }
}
```

</TabItem>
</Tabs>
````

Et vous obtiendrez les √©l√©ments suivants :

```mdx-code-block
<BrowserWindow>
<Tabs>
<TabItem value="js" label="JavaScript">
```

```js
function helloWorld() {
  console.log('Hello, world!');
}
```

```mdx-code-block
</TabItem>
<TabItem value="py" label="Python">
```

```py
def hello_world():
  print("Hello, world!")
```

```mdx-code-block
</TabItem>
<TabItem value="java" label="Java">
```

```java
class HelloWorld {
  public static void main(String args[]) {
    System.out.println("Hello, World");
  }
}
```

```mdx-code-block
</TabItem>
</Tabs>
</BrowserWindow>
```

Si vous avez plusieurs de ces onglets de code multi-langages, et que vous voulez synchroniser la s√©lection entre les instances de l'onglet, reportez-vous √† la section [Synchronisation des choix d'onglets](markdown-features-tabs.mdx#syncing-tab-choices).

### Plugin remark npm2yarn de Docusaurus {#npm2yarn-remark-plugin}

L'affichage des commandes CLI √† la fois pour npm et Yarn est un besoin tr√®s courant, par exemple¬†:

```bash npm2yarn
npm install @docusaurus/remark-plugin-npm2yarn
```

Docusaurus fournit un tel utilitaire d√®s le d√©part, vous √©vitant d'utiliser le composant `Tabs` √† chaque fois. Pour activer cette fonctionnalit√©, installez d'abord le paquet `@docusaurus/remark-plugin-npm2yarn` comme ci-dessus, puis dans `docusaurus.config.js`, pour les plugins o√π vous avez besoin de cette fonctionnalit√© (doc, blog, pages, etc.), enregistrez-la dans l'option `remarkPlugins`. (Consultez la [configuration des Docs](../../api/plugins/plugin-content-docs.mdx#ex-config) pour plus de d√©tails sur le format de configuration)

```js title="docusaurus.config.js"
export default {
  // ...
  presets: [
    [
      '@docusaurus/preset-classic',
      {
        docs: {
          // highlight-start
          remarkPlugins: [
            [require('@docusaurus/remark-plugin-npm2yarn'), {sync: true}],
          ],
          // highlight-end
        },
        pages: {
          // highlight-next-line
          remarkPlugins: [require('@docusaurus/remark-plugin-npm2yarn')],
        },
        blog: {
          // highlight-start
          remarkPlugins: [
            [
              require('@docusaurus/remark-plugin-npm2yarn'),
              {converters: ['pnpm']},
            ],
          ],
          // highlight-end
          // ...
        },
      },
    ],
  ],
};
```

Et puis utilisez-le en ajoutant la cl√© `npm2yarn` au bloc de code¬†:

````md
```bash npm2yarn
npm install @docusaurus/remark-plugin-npm2yarn
```
````

#### Configuration {#npm2yarn-remark-plugin-configuration}

| Option       | Type      | Par d√©faut         | Description                                                                                                                                         |
| ------------ | --------- | ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sync`       | `boolean` | `false`            | S'il faut synchroniser le convertisseur s√©lectionn√© sur tous les blocs de code.                                                                     |
| `converters` | `array`   | `'yarn'`, `'pnpm'` | La liste des convertisseurs √† utiliser. L'ordre des convertisseurs est important, car le premier convertisseur sera utilis√© comme choix par d√©faut. |

## Utilisation en JSX {#usage-in-jsx}

En dehors de Markdown, vous pouvez utiliser le composant `@theme/CodeBlock` pour obtenir le m√™me r√©sultat.

```jsx
import CodeBlock from '@theme/CodeBlock';

export default function MyReactPage() {
  return (
    <div>
      {/* highlight-start */}
      <CodeBlock
        language="jsx"
        title="/src/components/HelloCodeTitle.js"
        showLineNumbers>
        {`function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}`}
      </CodeBlock>
      {/* highlight-end */}
    </div>
  );
}
```

```mdx-code-block
<BrowserWindow>
  <CodeBlock
    language="jsx"
    title="/src/components/HelloCodeTitle.js"
    showLineNumbers>
    {`function HelloCodeTitle(props) {
  return <h1>Hello, {props.name}</h1>;
}`}
  </CodeBlock>
</BrowserWindow>
```

Les props accept√©s sont `language`, `title` et `showLineNumbers`, de la m√™me mani√®re que vous √©crivez des blocs de code Markdown.

Bien que d√©conseill√©, vous pouvez √©galement passer dans une prop `metastring` comme `metastring='{1-2} title="/src/components/HelloCodeTitle. s" showLineNumbers'`, qui est la fa√ßon dont les blocs de code Markdown sont g√©r√©s sous le capot. Cependant, nous vous recommandons d'[utiliser des commentaires pour mettre en √©vidence les lignes](#highlighting-with-comments).

Comme [indiqu√© pr√©c√©demment](#using-jsx-markup), la coloration syntaxique n'est appliqu√©e que lorsque les enfants sont une cha√Æne de caract√®res simple.
