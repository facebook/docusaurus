"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["53471"],{27397(e,t,r){r.d(t,{A:()=>a});let a={tabItem:"tabItem_pnkT"}},56679(e,t,r){r.d(t,{A:()=>a});let a={tabList:"tabList_Qoir",tabItem:"tabItem_AQgk"}},86469(e,t,r){r.d(t,{A:()=>a});let a=r.p+"assets/images/architecture-5b7220912f5cfdff40a7728233abb902.png"},32973(e,t,r){r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var a=r(11330),n=r(62540),s=r(43023);r(74644),r(82608);var i=r(87798);let o={description:"How Docusaurus works to build your app"},l="Architecture",u={},c=[];function d(e){let t={a:"a",code:"code",h1:"h1",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"architecture",children:"Architecture"})}),"\n","\n",(0,n.jsx)(i.A,{children:(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Architecture overview",src:r(86469).A+"",width:"2228",height:"2007"})})}),"\n",(0,n.jsx)(t.p,{children:"This diagram shows how Docusaurus works to build your app. Plugins each collect their content and emit JSON data; themes provide layout components which receive the JSON data as route modules. The bundler bundles all the components and emits a server bundle and a client bundle."}),"\n",(0,n.jsx)(t.p,{children:"Although you (either plugin authors or site creators) are writing JavaScript all the time, bear in mind that the JS is actually run in different environments:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["All plugin lifecycle methods are run in Node. Therefore, until we support ES Modules in our codebase, plugin source code must be provided as ES modules that can be imported, or CommonJS that can be ",(0,n.jsx)(t.code,{children:"require"}),"'d."]}),"\n",(0,n.jsx)(t.li,{children:"The theme code is built with Webpack. They can be provided as ESM\u2014following React conventions."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Plugin code and theme code never directly import each other: they only communicate through protocols (in our case, through JSON temp files and calls to ",(0,n.jsx)(t.code,{children:"addRoute"}),"). A useful mental model is to imagine that the plugins are not written in JavaScript, but in another language like Rust. The only way to interact with plugins for the user is through ",(0,n.jsx)(t.code,{children:"docusaurus.config.js"}),", which itself is run in Node (hence you can use ",(0,n.jsx)(t.code,{children:"require"})," and pass callbacks as plugin options)."]}),"\n",(0,n.jsxs)(t.p,{children:["During bundling, the config file itself is serialized and bundled, allowing the theme to access config options like ",(0,n.jsx)(t.code,{children:"themeConfig"})," or ",(0,n.jsx)(t.code,{children:"baseUrl"})," through ",(0,n.jsx)(t.a,{href:"/docs/docusaurus-core#useDocusaurusContext",children:(0,n.jsx)(t.code,{children:"useDocusaurusContext()"})}),". However, the ",(0,n.jsx)(t.code,{children:"siteConfig"})," object only contains ",(0,n.jsx)(t.strong,{children:"serializable values"})," (values that are preserved after ",(0,n.jsx)(t.code,{children:"JSON.stringify()"}),"). Functions, regexes, etc. would be lost on the client side. The ",(0,n.jsx)(t.code,{children:"themeConfig"})," is designed to be entirely serializable."]})]})}function h(e={}){let{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},82608(e,t,r){r.d(t,{A:()=>l});var a=r(62540);r(63696);var n=r(11750),s=r(25237),i=r(27397);function o({children:e,className:t,hidden:r}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,n.A)(i.A.tabItem,t),hidden:r,children:e})}function l({children:e,className:t,value:r}){let{selectedValue:n,lazy:i}=(0,s.uc)(),l=r===n;return!l&&i?null:(0,a.jsx)(o,{className:t,hidden:!l,children:e})}},74644(e,t,r){r.d(t,{A:()=>p});var a=r(62540);r(63696);var n=r(11750),s=r(2445),i=r(25237),o=r(70662),l=r(73749),u=r(56679);function c({className:e}){let{selectedValue:t,selectValue:r,tabValues:s,block:l}=(0,i.uc)(),c=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),h=e=>{let a=e.currentTarget,n=s[c.indexOf(a)].value;n!==t&&(d(a),r(n))},p=e=>{let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{let r=c.indexOf(e.currentTarget)+1;t=c[r]??c[0];break}case"ArrowLeft":{let r=c.indexOf(e.currentTarget)-1;t=c[r]??c[c.length-1]}}t?.focus()};return(0,a.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.A)("tabs",{"tabs--block":l},e),children:s.map(({value:e,label:r,attributes:s})=>(0,a.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{c.push(e)},onKeyDown:p,onClick:h,...s,className:(0,n.A)("tabs__item",u.A.tabItem,s?.className,{"tabs__item--active":t===e}),children:r??e},e))})}function d({children:e}){return(0,a.jsx)("div",{className:"margin-top--md",children:e})}function h({className:e,children:t}){return(0,a.jsxs)("div",{className:(0,n.A)(s.G.tabs.container,"tabs-container",u.A.tabList),children:[(0,a.jsx)(c,{className:e}),(0,a.jsx)(d,{children:t})]})}function p(e){let t=(0,l.A)(),r=(0,i.OC)(e);return(0,a.jsx)(i.O_,{value:r,children:(0,a.jsx)(h,{className:e.className,children:(0,i.vT)(e.children)})},String(t))}},25237(e,t,r){r.d(t,{OC:()=>h,O_:()=>f,uc:()=>b,vT:()=>c});var a=r(62540),n=r(63696),s=r(49519),i=r(66455),o=r(27611),l=r(78328),u=r(87116);function c(e){return n.Children.toArray(e).filter(e=>"\n"!==e)}function d({value:e,tabValues:t}){return t.some(t=>t.value===e)}function h(e){let t,{defaultValue:r,queryString:a=!1,groupId:c}=e,h=function(e){let{values:t,children:r}=e;return(0,n.useMemo)(()=>{let e=t??n.Children.toArray(r).flatMap(e=>{if(!e)return[];if((0,n.isValidElement)(e)&&function(e){let{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return[e];let t="string"==typeof e.type?e.type:e.type.name;throw Error(`Docusaurus error: Bad <Tabs> child <${t}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.
If you do not want to pass on a "value" prop to the direct children of <Tabs>, you can also pass an explicit <Tabs values={...}> prop.`)}).map(({props:{value:e,label:t,attributes:r,default:a}})=>({value:e,label:t,attributes:r,default:a})),a=(0,l.XI)(e,(e,t)=>e.value===t.value);if(a.length>0)throw Error(`Docusaurus error: Duplicate values "${a.map(e=>`'${e.value}'`).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[t,r])}(e),[p,b]=(0,n.useState)(()=>(function({defaultValue:e,tabValues:t}){if(0===t.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!d({value:e,tabValues:t}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let r=t.find(e=>e.default)??t[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:r,tabValues:h})),[f,m]=function({queryString:e=!1,groupId:t}){let r=(0,s.W6)(),a=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,o.aZ)(a),(0,n.useCallback)(e=>{if(!a)return;let t=new URLSearchParams(r.location.search);t.set(a,e),r.replace({...r.location,search:t.toString()})},[a,r])]}({queryString:a,groupId:c}),[v,g]=function({groupId:e}){let t=e?`docusaurus.tab.${e}`:null,[r,a]=(0,u.Dv)(t);return[r,(0,n.useCallback)(e=>{t&&a.set(e)},[t,a])]}({groupId:c}),x=d({value:t=f??v,tabValues:h})?t:null;return(0,i.A)(()=>{x&&b(x)},[x]),{selectedValue:p,selectValue:(0,n.useCallback)(e=>{if(!d({value:e,tabValues:h}))throw Error(`Can't select invalid tab value=${e}`);b(e),m(e),g(e)},[m,g,h]),tabValues:h,lazy:e.lazy??!1,block:e.block??!1}}let p=(0,n.createContext)(null);function b(){let e=n.useContext(p);if(!e)throw Error("useTabsContext() must be used within a Tabs component");return e}function f(e){return(0,a.jsx)(p.Provider,{value:e.value,children:e.children})}},11330(e){e.exports=JSON.parse('{"id":"advanced/architecture","title":"Architecture","description":"How Docusaurus works to build your app","source":"@site/docs/advanced/architecture.mdx","sourceDirName":"advanced","slug":"/advanced/architecture","permalink":"/docs/advanced/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/edit/main/website/docs/advanced/architecture.mdx","tags":[],"version":"current","lastUpdatedBy":"S\xe9bastien Lorber","lastUpdatedAt":1770998565000,"frontMatter":{"description":"How Docusaurus works to build your app"},"sidebar":"docs","previous":{"title":"Advanced Tutorials","permalink":"/docs/advanced/"},"next":{"title":"Plugins","permalink":"/docs/advanced/plugins"}}')}}]);