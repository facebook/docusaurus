/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

function execute() {
  const CWD = process.cwd();
  const fs = require("fs-extra");
  const readMetadata = require("./readMetadata.js");
  const renderToStaticMarkup = require("react-dom/server").renderToStaticMarkup;
  const path = require("path");
  const toSlug = require("../core/toSlug.js");
  const React = require("react");
  const mkdirp = require("mkdirp");
  const glob = require("glob");
  const Site = require("../core/Site.js");
  const siteConfig = require(CWD + "/siteConfig.js");
  const translate = require("./translate.js");
  let languages;
  if (fs.existsSync(CWD + "/languages.js")) {
    languages = require(CWD + "/languages.js");
  } else {
    languages = [
      {
        enabled: true,
        name: "English",
        tag: "en"
      }
    ];
  }

  function writeFileAndCreateFolder(file, content) {
    mkdirp.sync(file.replace(new RegExp("/[^/]*$"), ""));

    fs.writeFileSync(file, content);
  }

  const TABLE_OF_CONTENTS_TOKEN = "<AUTOGENERATED_TABLE_OF_CONTENTS>";

  const insertTableOfContents = rawContent => {
    const regexp = /\n###\s+(`.*`.*)\n/g;
    let match;
    const headers = [];
    while ((match = regexp.exec(rawContent))) {
      headers.push(match[1]);
    }

    const tableOfContents = headers
      .map(header => `  - [${header}](#${toSlug(header)})`)
      .join("\n");

    return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
  };

  function isSeparateCss(file) {
    if (!siteConfig.separateCss) {
      return false;
    }
    for (let i = 0; i < siteConfig.separateCss.length; i++) {
      if (file.includes(siteConfig.separateCss[i])) {
        return true;
      }
    }
    return false;
  }

  console.log("generate.js triggered...");

  const regexSubFolder = /docs\/(.*)\/.*/;

  const enabledLanguages = [];
  languages.filter(lang => lang.enabled).map(lang => {
    enabledLanguages.push(lang.tag);
  });

  readMetadata.generateDocsMetadata();
  const Metadata = require("../core/metadata.js");
  let mdToHtml = {};
  for (let i = 0; i < Metadata.length; i++) {
    const metadata = Metadata[i];
    mdToHtml["/docs/" + metadata.language + "/" + metadata.source] =
      "/" + siteConfig.projectName + "/" + metadata.permalink;
  }

  const DocsLayout = require("../core/DocsLayout.js");

  fs.removeSync(__dirname + "/../../build");

  // create html files for all docs
  let files = glob.sync(CWD + "/../docs/**");
  files.forEach(file => {
    // console.log(file);
    let language = "en";
    const match = regexSubFolder.exec(file);
    if (match) {
      language = match[1];
    }

    if (enabledLanguages.indexOf(language) === -1) {
      return;
    }

    const extension = path.extname(file);

    if (extension === ".md" || extension === ".markdown") {
      const result = readMetadata.processMetadata(file);
      if (!result) {
        return;
      }

      const metadata = result.metadata;
      let rawContent = result.rawContent;

      /* generate table of contents if appropriate */
      if (rawContent && rawContent.indexOf(TABLE_OF_CONTENTS_TOKEN) != -1) {
        rawContent = insertTableOfContents(rawContent);
      }

      /* replace any links to markdown files to their website html links */
      Object.keys(mdToHtml).forEach(function(key, index) {
        rawContent = rawContent.replace(new RegExp(key, "g"), mdToHtml[key]);
      });

      const docComp = (
        <DocsLayout metadata={metadata} language={language} config={siteConfig}>
          {rawContent}
        </DocsLayout>
      );
      const str = renderToStaticMarkup(docComp);

      let targetFile =
        __dirname +
        "/../../build" +
        "/" +
        siteConfig.projectName +
        "/" +
        metadata.permalink;
      // console.log(targetFile);
      writeFileAndCreateFolder(targetFile, str);
    }
  });

  // create html files for all blog posts
  if (fs.existsSync(__dirname + "../core/MetadataBlog.js")) {
    fs.removeSync(__dirname + "../core/MetadataBlog.js");
  }
  readMetadata.generateBlogMetadata();
  const MetadataBlog = require("../core/MetadataBlog.js");
  const BlogPostLayout = require("../core/BlogPostLayout.js");

  files = glob.sync(CWD + "/../blog/**/*.*");
  files.sort().reverse().forEach(file => {
    /* convert filename ot use slashes */
    const filePath = path
      .basename(file)
      .replace("-", "/")
      .replace("-", "/")
      .replace("-", "/")
      .replace(/\./g, "-")
      .replace(/\-md$/, ".html");
    const result = readMetadata.extractMetadata(
      fs.readFileSync(file, { encoding: "utf8" })
    );
    const rawContent = result.rawContent;
    const metadata = Object.assign(
      { path: filePath, content: rawContent },
      result.metadata
    );
    metadata.id = metadata.title;

    let language = "en";
    const blogPostComp = (
      <BlogPostLayout
        metadata={metadata}
        language={language}
        config={siteConfig}
      >
        {rawContent}
      </BlogPostLayout>
    );
    const str = renderToStaticMarkup(blogPostComp);

    let targetFile =
      __dirname +
      "/../../build" +
      "/" +
      siteConfig.projectName +
      "/" +
      "blog/" +
      filePath;
    writeFileAndCreateFolder(targetFile, str);
  });
  // create html files for all blog pages
  const BlogPageLayout = require("../core/BlogPageLayout.js");
  const perPage = 10;
  for (let page = 0; page < Math.ceil(MetadataBlog.length / perPage); page++) {
    let language = "en";
    const metadata = { page: page, perPage: perPage };
    const blogPageComp = (
      <BlogPageLayout
        metadata={metadata}
        language={language}
        config={siteConfig}
      />
    );
    const str = renderToStaticMarkup(blogPageComp);

    let targetFile =
      __dirname +
      "/../../build" +
      "/" +
      siteConfig.projectName +
      "/" +
      "blog" +
      (page > 0 ? "/page" + (page + 1) : "") +
      "/index.html";
    writeFileAndCreateFolder(targetFile, str);
  }

  /* copy all static files from docusaurus */
  files = glob.sync(__dirname + "/../static/**");
  files.forEach(file => {
    let targetFile = file.replace(
      "/lib/static/",
      "/build" + "/" + siteConfig.projectName + "/"
    );

    if (file.match(/\.css$/)) {
      let cssContent = fs.readFileSync(file);
      cssContent = cssContent
        .toString()
        .replace(
          new RegExp("{primaryColor}", "g"),
          siteConfig.colors.primaryColor
        );
      cssContent = cssContent.replace(
        new RegExp("{secondaryColor}", "g"),
        siteConfig.colors.secondaryColor
      );
      cssContent = cssContent.replace(
        new RegExp("{prismColor}", "g"),
        siteConfig.colors.prismColor
      );

      mkdirp.sync(targetFile.replace(new RegExp("/[^/]*$"), ""));
      fs.writeFileSync(targetFile, cssContent);
    } else if (!fs.lstatSync(file).isDirectory()) {
      mkdirp.sync(targetFile.replace(new RegExp("/[^/]*$"), ""));
      fs.copySync(file, targetFile);
    }
  });

  /* copy all static files from user */
  files = glob.sync(CWD + "/static/**");
  files.forEach(file => {
    if (file.match(/\.css$/) && !isSeparateCss(file)) {
      const mainCss =
        __dirname +
        "/../../build" +
        "/" +
        siteConfig.projectName +
        "/" +
        "css/main.css";
      let cssContent = fs.readFileSync(file);
      cssContent = fs.readFileSync(mainCss) + "\n" + cssContent;

      cssContent = cssContent
        .toString()
        .replace(
          new RegExp("{primaryColor}", "g"),
          siteConfig.colors.primaryColor
        );
      cssContent = cssContent.replace(
        new RegExp("{secondaryColor}", "g"),
        siteConfig.colors.secondaryColor
      );
      cssContent = cssContent.replace(
        new RegExp("{prismColor}", "g"),
        siteConfig.colors.prismColor
      );

      fs.writeFileSync(mainCss, cssContent);
    } else if (!fs.lstatSync(file).isDirectory()) {
      let parts = file.split("static");
      let targetFile =
        __dirname +
        "/../../build" +
        "/" +
        siteConfig.projectName +
        "/" +
        parts[1];
      mkdirp.sync(targetFile.replace(new RegExp("/[^/]*$"), ""));
      fs.copySync(file, targetFile);
    }
  });

  /* compile/copy pages from user */
  files = glob.sync(CWD + "/pages/**");
  files.forEach(file => {
    if (file.match(/\.js$/)) {
      /* make temp file for sake of require paths */
      const parts = file.split("pages");
      let tempFile = __dirname + "/../pages" + parts[1];
      tempFile = tempFile.replace(
        path.basename(file),
        "temp" + path.basename(file)
      );
      mkdirp.sync(tempFile.replace(new RegExp("/[^/]*$"), ""));
      fs.copySync(file, tempFile);

      const ReactComp = require(tempFile);

      let targetFile =
        __dirname + "/../../build/" + siteConfig.projectName + "/" + parts[1];
      targetFile = targetFile.replace(/\.js$/, ".html");

      const regexLang = /\/pages\/(.*)\//;
      const match = regexLang.exec(file);
      const langParts = match[1].split("/");
      if (langParts.indexOf("en") !== -1) {
        /* copy and compile a page for each enabled language from the English file */
        for (let i = 0; i < enabledLanguages.length; i++) {
          let language = enabledLanguages[i];
          /* skip conversion from english file if a file exists for this language */
          if (
            language !== "en" &&
            fs.existsSync(file.replace("/en/", "/" + language + "/"))
          ) {
            continue;
          }
          translate.setLanguage(language);
          const str = renderToStaticMarkup(
            <Site language={language} config={siteConfig}>
              <ReactComp language={language} />
            </Site>
          );
          writeFileAndCreateFolder(
            targetFile.replace("/en/", "/" + language + "/"),
            str
          );
        }
      } else {
        /* allow for rendering of other files not in pages/en folder */
        let language = "en";
        for (let i = 0; i < langParts.length; i++) {
          if (enabledLanguages.indexOf(langParts[i]) !== -1) {
            language = langParts[i];
          }
        }
        translate.setLanguage(language);
        const str = renderToStaticMarkup(
          <Site language={language} config={siteConfig}>
            <ReactComp language={language} />
          </Site>
        );
        writeFileAndCreateFolder(targetFile, str);
      }

      fs.removeSync(tempFile);
    } else if (!fs.lstatSync(file).isDirectory()) {
      let parts = file.split("pages");
      let targetFile =
        __dirname +
        "/../../build" +
        "/" +
        siteConfig.projectName +
        "/" +
        parts[1];
      mkdirp.sync(targetFile.replace(new RegExp("/[^/]*$"), ""));
      fs.copySync(file, targetFile);
    }
  });

  /* copy html files in 'en' to base level as well */
  files = glob.sync(
    __dirname + "/../../build" + "/" + siteConfig.projectName + "/" + "en/**"
  );
  files.forEach(file => {
    let targetFile = file.replace("en/", "");
    if (file.match(/\.html$/)) {
      fs.copySync(file, targetFile);
    }
  });

  /* Generate CNAME file if a custom domain is specified in siteConfig */
  if (siteConfig.cname) {
    let targetFile = CWD + "/build/" + siteConfig.projectName + "/CNAME";
    fs.writeFileSync(targetFile, siteConfig.cname);
  }
}

module.exports = execute;
